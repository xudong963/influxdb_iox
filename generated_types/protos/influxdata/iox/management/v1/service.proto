syntax = "proto3";
package influxdata.iox.management.v1;
option go_package = "github.com/influxdata/iox/management/v1";

import "google/longrunning/operations.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";
import "influxdata/iox/management/v1/database_rules.proto";
import "influxdata/iox/management/v1/chunk.proto";
import "influxdata/iox/management/v1/partition.proto";

service ManagementService {
  // Get server ID.
  //
  // This call is deprecated, see <https://github.com/influxdata/influxdb_iox/issues/2980>.
  rpc GetServerId(GetServerIdRequest) returns (GetServerIdResponse) {
    option deprecated = true;
  };

  // Update server ID.
  //
  // This call is deprecated, see <https://github.com/influxdata/influxdb_iox/issues/2980>.
  rpc UpdateServerId(UpdateServerIdRequest) returns (UpdateServerIdResponse) {
    option deprecated = true;
  };

  // Set serving readiness.
  //
  // This call is deprecated, see <https://github.com/influxdata/influxdb_iox/issues/2980>.
  rpc SetServingReadiness(SetServingReadinessRequest) returns (SetServingReadinessResponse) {
    option deprecated = true;
  };

  // List all databases on this server.
  //
  // Roughly follows the <https://google.aip.dev/132> pattern, except we wrap the response
  rpc ListDatabases(ListDatabasesRequest) returns (ListDatabasesResponse);

  // Return a specific database by name
  //
  // Roughly follows the <https://google.aip.dev/131> pattern, except
  // we wrap the response
  rpc GetDatabase(GetDatabaseRequest) returns (GetDatabaseResponse);

  rpc CreateDatabase(CreateDatabaseRequest) returns (CreateDatabaseResponse);

  // Update a database.
  //
  // Roughly follows the <https://google.aip.dev/134> pattern, except we wrap the response
  rpc UpdateDatabase(UpdateDatabaseRequest) returns (UpdateDatabaseResponse);

  // Delete a database.
  rpc DeleteDatabase(DeleteDatabaseRequest) returns (DeleteDatabaseResponse);

  // Disown a database from its current server.
  rpc DisownDatabase(DisownDatabaseRequest) returns (DisownDatabaseResponse);

  // Restore a deleted database.
  rpc RestoreDatabase(RestoreDatabaseRequest) returns (RestoreDatabaseResponse);

  // Adopt a disowned database.
  rpc AdoptDatabase(AdoptDatabaseRequest) returns (AdoptDatabaseResponse);

  // List databases with their metadata.
  rpc ListDetailedDatabases(ListDetailedDatabasesRequest) returns (ListDetailedDatabasesResponse);

  // List chunks available on this database
  rpc ListChunks(ListChunksRequest) returns (ListChunksResponse);

  // List remote IOx servers we know about.
  //
  // This call is deprecated, see <https://github.com/influxdata/influxdb_iox/issues/2980>.
  rpc ListRemotes(ListRemotesRequest) returns (ListRemotesResponse) {
    option deprecated = true;
  };

  // Update information about a remote IOx server (upsert).
  //
  // This call is deprecated, see <https://github.com/influxdata/influxdb_iox/issues/2980>.
  rpc UpdateRemote(UpdateRemoteRequest) returns (UpdateRemoteResponse) {
    option deprecated = true;
  };

  // Delete a reference to remote IOx server.
  //
  // This call is deprecated, see <https://github.com/influxdata/influxdb_iox/issues/2980>.
  rpc DeleteRemote(DeleteRemoteRequest) returns (DeleteRemoteResponse) {
    option deprecated = true;
  };

  // Creates a dummy job that for each value of the nanos field
  // spawns a task that sleeps for that number of nanoseconds before returning
  rpc CreateDummyJob(CreateDummyJobRequest) returns (CreateDummyJobResponse) {
    option (google.longrunning.operation_info) = {
      response_type: "google.protobuf.Empty"
      metadata_type: "OperationMetadata"
    };
  }

  // List partitions in a database
  rpc ListPartitions(ListPartitionsRequest) returns (ListPartitionsResponse);

  // Get detail information about a partition
  rpc GetPartition(GetPartitionRequest) returns (GetPartitionResponse);

  // List chunks in a partition
  rpc ListPartitionChunks(ListPartitionChunksRequest) returns (ListPartitionChunksResponse);

  // Create a new chunk in the mutable buffer
  rpc NewPartitionChunk(NewPartitionChunkRequest) returns (NewPartitionChunkResponse);

  // Close a chunk and move it to the read buffer
  rpc ClosePartitionChunk(ClosePartitionChunkRequest) returns (ClosePartitionChunkResponse);

  // Unload chunk from read buffer but keep it in object store
  rpc UnloadPartitionChunk(UnloadPartitionChunkRequest) returns (UnloadPartitionChunkResponse);

  // Get server status
  rpc GetServerStatus(GetServerStatusRequest) returns (GetServerStatusResponse);

  // Wipe preserved catalog for given DB.
  rpc WipePreservedCatalog(WipePreservedCatalogRequest) returns (WipePreservedCatalogResponse);

  // Skip replay for given DB.
  rpc SkipReplay(SkipReplayRequest) returns (SkipReplayResponse);

  // Persist given partition.
  //
  // Errors if there is nothing to persist at the moment as per the lifecycle rules. If successful it returns the
  // chunk that contains the persisted data.
  rpc PersistPartition(PersistPartitionRequest) returns (PersistPartitionResponse);

  // Drop partition from memory and (if persisted) from object store.
  rpc DropPartition(DropPartitionRequest) returns (DropPartitionResponse);

  // Delete data for a table on a specified predicate
  rpc Delete(DeleteRequest) returns (DeleteResponse) {
    option deprecated = true;
  };
}

message GetServerIdRequest {}

message GetServerIdResponse {
  // Must be non-zero
  uint32 id = 1;
}

message UpdateServerIdRequest {
  // Must be non-zero
  uint32 id = 1;
}

message UpdateServerIdResponse {}

message SetServingReadinessRequest {
  // If false, the IOx server will respond with UNAVAILABLE to all data plane requests.
  bool ready = 1;
}

message SetServingReadinessResponse {}

message ListDatabasesRequest {
  // If true, returns only explicitly defined values. See additional
  // details on `GetDatabaseRequest`.
  bool omit_defaults = 1;
}

message ListDatabasesResponse {
  // old version of this API returned names only.
  // repeated string names = 1;

  /// database rules (configuration) for each database
  repeated DatabaseRules rules = 2;
}

message GetDatabaseRequest {
  // The name of the database to retrieve
  string name = 1;

  // If false: return the current configuration that is being used by
  // the server, with all server-side default values filled in.
  //
  // If true, returns only the persisted configuration (aka only
  // fields which were was supplied when the database was created or
  // last modified via UpdateDatabase)
  bool omit_defaults = 2;
}

message GetDatabaseResponse {
  DatabaseRules rules = 1;
}

message CreateDatabaseRequest {
  DatabaseRules rules = 1;
}

message CreateDatabaseResponse {
  bytes uuid = 1;
}

// Update a database.
message UpdateDatabaseRequest {
  // The rule's `name` field is used to identify the database rules to be updated.
  DatabaseRules rules = 1;
}

message UpdateDatabaseResponse {
  DatabaseRules rules = 1;
}

message DeleteDatabaseRequest {
  // the name of the database
  string db_name = 1;
}

message DeleteDatabaseResponse {
  bytes uuid = 1;
}

message DisownDatabaseRequest {
  // the name of the database
  string db_name = 1;

  // the optional UUID of the database that must match
  bytes uuid = 2;
}

message DisownDatabaseResponse {
  bytes uuid = 1;
}

message RestoreDatabaseRequest {
  // Was the generation ID of the deleted database.
  reserved 1;
  reserved "generation_id";

  // Was the name of the database
  reserved 2;
  reserved "db_name";

  // Was the string-formatted UUID of the deleted database.
  reserved 3;

  // The UUID of the deleted database.
  bytes uuid = 4;
}

message RestoreDatabaseResponse {}

message AdoptDatabaseRequest {
  bytes uuid = 1;
}

message AdoptDatabaseResponse {
  string db_name = 1;
}

message ListDetailedDatabasesRequest {}

message ListDetailedDatabasesResponse {
  repeated DetailedDatabase databases = 1;
}

// This resource represents detailed information about a database.
message DetailedDatabase {
  // Was the generation ID of the database.
  reserved 1;
  reserved "generation_id";

  // Was the datetime at which this database was deleted, if applicable.
  reserved 2;
  reserved "deleted_at";

  // The name of the database.
  string db_name = 3;

  // The UUID of the database.
  bytes uuid = 4;
}

message ListChunksRequest {
  // the name of the database
  string db_name = 1;
}

message ListChunksResponse {
  repeated Chunk chunks = 1;
}

message CreateDummyJobRequest {
  repeated uint64 nanos = 1;
}

message CreateDummyJobResponse {
  google.longrunning.Operation operation = 1;
}

message ListRemotesRequest {}

message ListRemotesResponse {
  repeated Remote remotes = 1;
}

// This resource represents a remote IOx server.
message Remote {
  // The server ID associated with a remote IOx server.
  uint32 id = 1;

  // The address of the remote IOx server gRPC endpoint.
  string connection_string = 2;
}

// Updates information about a remote IOx server.
//
// If a remote for a given `id` already exists, it is updated in place.
message UpdateRemoteRequest {
  // If omitted, the remote associated with `id` will be removed.
  Remote remote = 1;

  // TODO(#917): add an optional flag to test the connection or not before adding it.
}

message UpdateRemoteResponse {}

message DeleteRemoteRequest{
  uint32 id = 1;
}

message DeleteRemoteResponse {}

// Request to list all partitions from a named database
message ListPartitionsRequest {
  // the name of the database
  string db_name = 1;
}

message ListPartitionsResponse {
  // All partitions in a database
  repeated Partition partitions = 1;
}

// Request to list all chunks in a specific partitions from a named database
message ListPartitionChunksRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;
}

message GetPartitionResponse {
  // Detailed information about a partition
  Partition partition = 1;
}

message ListPartitionChunksResponse {
  // All chunks in a partition
  repeated Chunk chunks = 1;
}

// Request to get details of a specific partition from a named database
message GetPartitionRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;
}

// Request that a new chunk for writing is created in the mutable buffer
message NewPartitionChunkRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;

  // the table name
  string table_name = 3;
}

message NewPartitionChunkResponse {
}

// Request that a chunk be closed and moved to the read buffer
message ClosePartitionChunkRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;

  // the table name
  string table_name = 4;

  // Was uint32-based chunk ID.
  reserved 3;

  // the chunk id
  //
  // UUID is stored as 16 bytes in big-endian order.
  bytes chunk_id = 5;
}

message ClosePartitionChunkResponse {
  // The operation that tracks the work for migrating the chunk
  google.longrunning.Operation operation = 1;
}

// Request to unload chunk from read buffer but keep it in object store
message UnloadPartitionChunkRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;

  // the table name
  string table_name = 4;

  // Was uint32-based chunk ID.
  reserved 3;

  // the chunk id
  //
  // UUID is stored as 16 bytes in big-endian order.
  bytes chunk_id = 5;
}

message UnloadPartitionChunkResponse {
}

message GetServerStatusRequest {}
message GetServerStatusResponse {
  // Server status.
  ServerStatus server_status = 1;
}

message ServerStatus {
  // Server is initialized, i.e. databases are loaded and accept read/write operations. Furthermore database rules can
  // be updaded and new databases can be created.
  bool initialized = 1;

  // If present, the server reports a global error condition.
  Error error = 2;

  // If `initialized` is true, this contains a complete list of databases.
  repeated DatabaseStatus database_statuses = 3;
}

message DatabaseStatus {
  // The name of the database.
  string db_name = 1;

  // If present, the database reports an error condition.
  Error error = 2;

  // Current initialization state of the database.
  enum DatabaseState {
    DATABASE_STATE_UNSPECIFIED = 0;

    // Database is known but nothing is loaded.
    DATABASE_STATE_KNOWN = 1;

    // Database object storage has been found
    DATABASE_STATE_DATABASE_OBJECT_STORE_FOUND = 8;

    // No active database
    DATABASE_STATE_NO_ACTIVE_DATABASE = 10;

    // Database owner info has been loaded
    DATABASE_STATE_OWNER_INFO_LOADED = 11;

    // Rules are loaded
    DATABASE_STATE_RULES_LOADED = 2;

    // Catalog is loaded but data from sequencers / write buffers is not yet replayed.
    DATABASE_STATE_CATALOG_LOADED = 3;

    // Fully initialized database.
    DATABASE_STATE_INITIALIZED = 4;

    // Error loading rules
    DATABASE_STATE_RULES_LOAD_ERROR = 5;

    // Error loading owner info
    DATABASE_STATE_OWNER_INFO_LOAD_ERROR = 12;

    // Error during catalog load
    DATABASE_STATE_CATALOG_LOAD_ERROR = 6;

    // Error during replay
    DATABASE_STATE_REPLAY_ERROR = 7;

    // Error encountered finding the database's directory in object storage
    DATABASE_STATE_DATABASE_OBJECT_STORE_LOOKUP_ERROR = 9;
  }

  // Current initialization state of the database.
  DatabaseState state = 3;
}

message Error {
  // Message describing the error.
  string message = 1;
}

// Request to wipe preserved catalog.
message WipePreservedCatalogRequest {
  // the name of the database
  string db_name = 1;
}

message WipePreservedCatalogResponse {
  // The operation that tracks the work for wiping the catalog.
  google.longrunning.Operation operation = 1;
}

// Request to skip replay.
message SkipReplayRequest {
  // the name of the database
  string db_name = 1;
}

message SkipReplayResponse {
}

// Request to persist given partition.
message PersistPartitionRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;

  // the table name
  string table_name = 3;
}

message PersistPartitionResponse {
}

// Request to drop partition from memory and (if persisted) from object store.
message DropPartitionRequest {
  // the name of the database
  string db_name = 1;

  // the partition key
  string partition_key = 2;

  // the table name
  string table_name = 3;
}

message DropPartitionResponse {
}

// Request to delete data from a table on a specified predicate
message DeleteRequest {
  // name of the database
  string db_name = 1;

  // table name
  string table_name = 2;

  // start time range
  string start_time = 3;

  // stop time range
  string stop_time = 4;

  // predicate
  // conjunctive expressions of binary 'column_name = literal' or 'column_ame != literal'
  string predicate = 5;
}

message DeleteResponse {
}
